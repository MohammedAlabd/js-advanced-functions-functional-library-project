const fi = (function() {
  return {
    libraryMethod: function() {
      return 'Start by reading https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0'
    },

    // NOTE: 'each', 'map', 'reduce', 'find', 'filter' and 'size' should work if either an array or object is passed in as the argument
    // HINT: how can we turn an object into an array?
    // HINT: remember that 'each' should return the original array
    each: function() {

    },

    // HINT: remember that 'map' should return the modified array
    map: function() {

    },

    // NOTE: for reduce, your function should accept a collection, a callback, and an accumulator as arguments
    // HINT: how can we handle the case when an accumulator is not passed in?
    reduce: function() {

    },
    
    // NOTE: for find, your function should accept a collection and a predicate (a callback function 
    // that returns true or false) as arguments
    find: function() {
      
    },
    
    // NOTE: for filter, your function should accept a collection and a predicate (a callback function 
    // that returns true or false) as arguments
    filter: function() {
      
    },
    
    size: function() {
      
    },
    
    
    // NOTE: 'first', 'last', 'compact', 'sortBy', 'flatten', and 'uniq' are array functions - you do not
    // need to make them work for objects
    first: function() {
      
    },
    
    last: function() {
      
    },
    
    // NOTE: for this function, you should explicitly check for the falsy values listed in the instructions
    // (false, null, 0, "", undefined and NaN); do not rely on the bang operator (!)
    compact: function() {
      
    },
    
    sortBy: function() {
      
    },
    
    // NOTE: 'flatten' should accept an array and an optional boolean parameter 'shallow'; it will return a new, flattened array
    // HINT: how can we handle the case where 'shallow' is not passed in?
    // HINT: you will need to use recursion to code this lab for the case where 'shallow' is not passed in
    // HINT: for the case where we're using recursion, how can we make sure that the new array we're creating is not overwritten 
    // when we call the function?
    flatten: function() {
      
    },
    
    // NOTE: 'uniq' should accept an array, an optional boolean parameter 'sorted', and an optional 'iteratee' (callback function);
    // it should return a new array with just the unique values
    // HINT: how can we handle the case where 'sorted' or 'iteratee' are not passed in?
    // HINT: to complete this function, you should research 'new Set' and 'Array.from' commands
    // NOTE: the case where the 'sorted' variable is true is *NOT* tested in this lab so you will not have test errors to help you; 
    // for this reason, writing the code for this case (sorted = true) is OPTIONAL
    uniq: function() {
      
    },
    
    
    // NOTE: 'keys', 'values', and 'functions' are object functions
    keys: function() {
      
    },
    
    values: function() {
      
    },
    
    // NOTE: the instructions specify that the functions should be sorted in the output array but the test doesn't check for that. 
    // How can we make sure that the array returned at the end is sorted?
    functions: function() {

    },


  }
})()

fi.libraryMethod()
